package mcptools

import (
	"context"

	"github.com/dusk-indust/decompose/internal/orchestrator"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// NewUnifiedMCPServer creates a single MCP server that registers all tools:
// 3 decompose tools (run_stage, get_status, list_decompositions),
// 2 hybrid tools (write_stage, get_stage_context),
// and 5 code intelligence tools (build_graph, query_symbols, get_dependencies,
// assess_impact, get_clusters).
func NewUnifiedMCPServer(pipeline orchestrator.Orchestrator, cfg orchestrator.Config, codeintel *CodeIntelService) *mcp.Server {
	decomposeSvc := NewDecomposeService(pipeline, cfg)

	server := mcp.NewServer(&mcp.Implementation{
		Name:    "decompose",
		Version: version,
	}, nil)

	// --- Decompose tools ---

	mcp.AddTool(server, &mcp.Tool{
		Name:        "run_stage",
		Description: "Execute a single decomposition pipeline stage (0-4). Returns the files written. In basic/mcp-only mode this produces template scaffolds; use write_stage for rich content.",
	}, decomposeSvc.RunStage)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "get_status",
		Description: "Get the status of a decomposition: which stages are complete and what stage is next.",
	}, decomposeSvc.GetStatus)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "list_decompositions",
		Description: "List all decompositions in the project, showing completion status for each.",
	}, decomposeSvc.ListDecompositions)

	// --- Hybrid tools (Claude generates content, binary validates + writes) ---

	mcp.AddTool(server, &mcp.Tool{
		Name:        "write_stage",
		Description: "Validate, merge, and write stage content generated by Claude. Accepts named sections, runs coherence checking, merges in template order, and writes the output file. Use this instead of manually writing stage files.",
	}, decomposeSvc.WriteStage)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "get_stage_context",
		Description: "Get everything needed to generate a stage: the template, section names, and content from prerequisite stages. Call this before generating sections for a stage.",
	}, decomposeSvc.GetStageContext)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "set_input",
		Description: "Store a high-level input file or content for a decomposition. The content is included in get_stage_context output for Stage 1.",
	}, decomposeSvc.SetInput)

	// --- Code intelligence tools ---

	if codeintel != nil {
		mcp.AddTool(server, &mcp.Tool{
			Name:        "build_graph",
			Description: "Index a repository and build the code intelligence graph. Walks the file tree, parses source files using tree-sitter, extracts symbols and dependencies, and computes file clusters.",
		}, codeintel.BuildGraph)

		mcp.AddTool(server, &mcp.Tool{
			Name:        "query_symbols",
			Description: "Search for symbols (functions, classes, types, etc.) by name substring match. Optionally filter by symbol kind and limit results.",
		}, codeintel.QuerySymbols)

		mcp.AddTool(server, &mcp.Tool{
			Name:        "get_dependencies",
			Description: "Traverse the dependency graph upstream or downstream from a file or symbol. Returns dependency chains up to the specified depth.",
		}, codeintel.GetDependencies)

		mcp.AddTool(server, &mcp.Tool{
			Name:        "assess_impact",
			Description: "Compute the blast radius of modifying a set of files. Returns directly and transitively affected files with a risk score.",
		}, codeintel.AssessImpact)

		mcp.AddTool(server, &mcp.Tool{
			Name:        "get_clusters",
			Description: "Return all file clusters discovered during graph building. Clusters are groups of tightly connected files with cohesion scores.",
		}, codeintel.GetClusters)

		mcp.AddTool(server, &mcp.Tool{
			Name:        "generate_diagram",
			Description: "Generate a Mermaid dependency diagram from the code graph. Clusters become subgraphs, imports become arrows.",
		}, codeintel.GenerateDiagram)
	}

	return server
}

// RunUnifiedMCPServerStdio runs the unified MCP server on stdio transport,
// blocking until stdin is closed or the context is cancelled.
func RunUnifiedMCPServerStdio(ctx context.Context, server *mcp.Server) error {
	return server.Run(ctx, &mcp.StdioTransport{})
}
