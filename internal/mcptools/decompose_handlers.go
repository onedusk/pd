package mcptools

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/dusk-indust/decompose/internal/orchestrator"
	"github.com/dusk-indust/decompose/internal/skilldata"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// DecomposeService handles MCP tool calls for the decompose server mode.
// It wraps an Orchestrator to execute pipeline stages and query status.
type DecomposeService struct {
	pipeline orchestrator.Orchestrator
	cfg      orchestrator.Config

	mu           sync.RWMutex
	inputContent map[string]string // decomposition name â†’ input content
}

// NewDecomposeService creates a DecomposeService with the given pipeline and config.
func NewDecomposeService(pipeline orchestrator.Orchestrator, cfg orchestrator.Config) *DecomposeService {
	return &DecomposeService{
		pipeline:     pipeline,
		cfg:          cfg,
		inputContent: make(map[string]string),
	}
}

// RunStage executes a single pipeline stage and returns the files written.
func (s *DecomposeService) RunStage(
	ctx context.Context,
	_ *mcp.CallToolRequest,
	input RunStageInput,
) (*mcp.CallToolResult, RunStageOutput, error) {
	if input.Stage < 0 || input.Stage > 4 {
		return nil, RunStageOutput{
			Stage:   input.Stage,
			Status:  "failed",
			Message: fmt.Sprintf("stage must be 0-4, got %d", input.Stage),
		}, fmt.Errorf("invalid stage number: %d", input.Stage)
	}

	stage := orchestrator.Stage(input.Stage)
	result, err := s.pipeline.RunStage(ctx, stage)
	if err != nil {
		return nil, RunStageOutput{
			Stage:   input.Stage,
			Status:  "failed",
			Message: err.Error(),
		}, nil
	}

	return nil, RunStageOutput{
		FilesWritten: result.FilePaths,
		Stage:        input.Stage,
		Status:       "completed",
	}, nil
}

// GetStatus reports which stages are complete for a named decomposition.
func (s *DecomposeService) GetStatus(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input GetStatusInput,
) (*mcp.CallToolResult, GetStatusOutput, error) {
	name := input.Name
	if name == "" {
		name = s.cfg.Name
	}

	outputDir := filepath.Join(s.cfg.ProjectRoot, "docs", "decompose", name)
	completed := scanCompletedStages(outputDir)
	next := nextStage(completed)

	return nil, GetStatusOutput{
		Name:            name,
		CompletedStages: completed,
		NextStage:       next,
		CapabilityLevel: s.cfg.Capability.String(),
	}, nil
}

// ListDecompositions scans the docs/decompose directory for all decompositions.
func (s *DecomposeService) ListDecompositions(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input ListDecompositionsInput,
) (*mcp.CallToolResult, ListDecompositionsOutput, error) {
	projectRoot := input.ProjectRoot
	if projectRoot == "" {
		projectRoot = s.cfg.ProjectRoot
	}

	decomposeDir := filepath.Join(projectRoot, "docs", "decompose")
	entries, err := os.ReadDir(decomposeDir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, ListDecompositionsOutput{}, nil
		}
		return nil, ListDecompositionsOutput{}, fmt.Errorf("read decompose dir: %w", err)
	}

	var summaries []DecompositionSummary
	hasStage0 := false

	for _, entry := range entries {
		if !entry.IsDir() {
			// Check for shared stage-0 file at the top level.
			if strings.HasPrefix(entry.Name(), "stage-0-") {
				hasStage0 = true
			}
			continue
		}

		name := entry.Name()
		subDir := filepath.Join(decomposeDir, name)
		completed := scanCompletedStages(subDir)

		summaries = append(summaries, DecompositionSummary{
			Name:            name,
			CompletedStages: completed,
			NextStage:       nextStage(completed),
		})
	}

	return nil, ListDecompositionsOutput{
		Decompositions: summaries,
		HasStage0:      hasStage0,
	}, nil
}

// scanCompletedStages checks which stage output files exist in a directory.
func scanCompletedStages(dir string) []int {
	var completed []int
	for stage := 0; stage <= 4; stage++ {
		s := orchestrator.Stage(stage)
		filename := fmt.Sprintf("stage-%d-%s.md", stage, s.String())
		path := filepath.Join(dir, filename)
		if _, err := os.Stat(path); err == nil {
			completed = append(completed, stage)
		}
	}
	return completed
}

// nextStage returns the next stage to run based on completed stages.
func nextStage(completed []int) int {
	if len(completed) == 0 {
		return 0
	}
	max := completed[0]
	for _, s := range completed[1:] {
		if s > max {
			max = s
		}
	}
	next := max + 1
	if next > 4 {
		next = -1 // all stages complete
	}
	return next
}

// WriteStage validates, merges, and writes stage content generated by Claude.
// It uses the orchestrator's MergePlan and CheckCoherence to ensure consistency.
func (s *DecomposeService) WriteStage(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input WriteStageInput,
) (*mcp.CallToolResult, WriteStageOutput, error) {
	if input.Stage < 0 || input.Stage > 4 {
		return nil, WriteStageOutput{
			Status:  "failed",
			Message: fmt.Sprintf("stage must be 0-4, got %d", input.Stage),
		}, fmt.Errorf("invalid stage number: %d", input.Stage)
	}
	if len(input.Sections) == 0 {
		return nil, WriteStageOutput{
			Status:  "failed",
			Message: "at least one section is required",
		}, fmt.Errorf("no sections provided")
	}

	stage := orchestrator.Stage(input.Stage)

	// Convert input sections to orchestrator.Section for merge + coherence.
	sections := make([]orchestrator.Section, len(input.Sections))
	for i, sec := range input.Sections {
		sections[i] = orchestrator.Section{
			Name:    sec.Name,
			Content: sec.Content,
			Agent:   "claude",
		}
	}

	// Get the merge plan for this stage.
	plan := orchestrator.MergePlanForStage(stage)

	// Run coherence check.
	issues, _ := orchestrator.CheckCoherence(sections)
	var issueStrs []string
	for _, iss := range issues {
		issueStrs = append(issueStrs, iss.Description)
	}

	// Merge sections according to plan order.
	merger := orchestrator.NewMerger(plan)
	merged, err := merger.Merge(sections)
	if err != nil {
		return nil, WriteStageOutput{
			Status:          "failed",
			Message:         fmt.Sprintf("merge failed: %v", err),
			CoherenceIssues: issueStrs,
		}, nil
	}

	// Determine output path.
	name := input.Name
	if name == "" {
		name = s.cfg.Name
	}
	outputDir := filepath.Join(s.cfg.ProjectRoot, "docs", "decompose", name)
	if stage == orchestrator.StageDevelopmentStandards {
		outputDir = filepath.Join(s.cfg.ProjectRoot, "docs", "decompose")
	}
	outPath := filepath.Join(outputDir, fmt.Sprintf("stage-%d-%s.md", int(stage), stage.String()))

	// Create directory and write file.
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		return nil, WriteStageOutput{
			Status:  "failed",
			Message: fmt.Sprintf("mkdir: %v", err),
		}, nil
	}
	if err := os.WriteFile(outPath, []byte(merged), 0o644); err != nil {
		return nil, WriteStageOutput{
			Status:  "failed",
			Message: fmt.Sprintf("write: %v", err),
		}, nil
	}

	return nil, WriteStageOutput{
		FilesWritten:    []string{outPath},
		CoherenceIssues: issueStrs,
		Status:          "completed",
	}, nil
}

// GetStageContext returns the template, section names, and prerequisite content
// needed to generate a stage. Claude calls this before generating sections.
func (s *DecomposeService) GetStageContext(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input GetStageContextInput,
) (*mcp.CallToolResult, GetStageContextOutput, error) {
	if input.Stage < 0 || input.Stage > 4 {
		return nil, GetStageContextOutput{}, fmt.Errorf("stage must be 0-4, got %d", input.Stage)
	}

	stage := orchestrator.Stage(input.Stage)
	plan := orchestrator.MergePlanForStage(stage)

	// Load template from embedded skill files.
	templatePath := fmt.Sprintf("skill/decompose/assets/templates/stage-%d-%s.md", input.Stage, stage.String())
	templateData, err := skilldata.SkillFS.ReadFile(templatePath)
	if err != nil {
		return nil, GetStageContextOutput{}, fmt.Errorf("read template %s: %w", templatePath, err)
	}

	// Read prerequisite stage outputs.
	name := input.Name
	if name == "" {
		name = s.cfg.Name
	}
	outputDir := filepath.Join(s.cfg.ProjectRoot, "docs", "decompose", name)
	var prereqParts []string

	// Stage 0 is at the root.
	stage0Path := filepath.Join(s.cfg.ProjectRoot, "docs", "decompose",
		fmt.Sprintf("stage-0-%s.md", orchestrator.StageDevelopmentStandards.String()))
	if data, err := os.ReadFile(stage0Path); err == nil && input.Stage > 0 {
		prereqParts = append(prereqParts, fmt.Sprintf("### Stage 0: Development Standards\n\n%s", string(data)))
	}

	// Stages 1-3 in the named directory.
	for s := 1; s < input.Stage; s++ {
		st := orchestrator.Stage(s)
		p := filepath.Join(outputDir, fmt.Sprintf("stage-%d-%s.md", s, st.String()))
		if data, err := os.ReadFile(p); err == nil {
			prereqParts = append(prereqParts, fmt.Sprintf("### Stage %d: %s\n\n%s", s, st.String(), string(data)))
		}
	}

	prerequisites := ""
	if len(prereqParts) > 0 {
		prerequisites = strings.Join(prereqParts, "\n\n---\n\n")
	}

	// Check for stored input content.
	s.mu.RLock()
	inputContent := s.inputContent[name]
	s.mu.RUnlock()

	return nil, GetStageContextOutput{
		StageName:      stage.String(),
		SectionNames:   plan.SectionOrder,
		Prerequisites:  prerequisites,
		Template:       string(templateData),
		GraphAvailable: true,
		InputContent:   inputContent,
	}, nil
}

// SetInput stores a high-level input file/content for a decomposition.
// This is included in get_stage_context output for Stage 1.
func (s *DecomposeService) SetInput(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input SetInputInput,
) (*mcp.CallToolResult, SetInputOutput, error) {
	content := input.Content
	if input.FilePath != "" {
		data, err := os.ReadFile(input.FilePath)
		if err != nil {
			return nil, SetInputOutput{Status: "failed"}, fmt.Errorf("read input file: %w", err)
		}
		content = string(data)
	}
	if content == "" {
		return nil, SetInputOutput{Status: "failed"}, fmt.Errorf("either filePath or content is required")
	}

	name := input.Name
	if name == "" {
		name = s.cfg.Name
	}

	s.mu.Lock()
	s.inputContent[name] = content
	s.mu.Unlock()

	return nil, SetInputOutput{
		Status:       "completed",
		ContentBytes: len(content),
	}, nil
}
